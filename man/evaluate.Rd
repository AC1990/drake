% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate.R
\name{evaluate}
\alias{evaluate}
\title{Function \command{evaluate}}
\usage{
evaluate(x, rules = NULL, wildcard = NULL, values = NULL, expand = TRUE)
}
\arguments{
\item{x}{argument data frame}

\item{rules}{Named list with wildcards as names and vectors of replacements
as values. This is a way to evaluate multiple wildcards at once.}

\item{wildcard}{character string to replace with elements of \command{values}.}

\item{values}{values to replace the wildcard in the drake instructions. Must be
the same length as \command{x$command} if \command{expand} is \command{TRUE}.}

\item{expand}{If \command{TRUE}, loop over \command{values} when evaluating the wildcard,
creating more rows in the target data frame. Otherwise, each occurance of the wildcard
is replaced with the next entry in the \command{values} vector, and the values are recycled.}
}
\value{
an evaluated data frame
}
\description{
Evaluates the wildcard placeholders of a data frame of \command{drake} instructions.
}
\details{
If \command{wildcard} and \command{values} are not \command{NULL}, the members of 
\command{values} will replace \command{wildcard} in the \command{command}
column of \command{x}. If the \command{rules} list is not \command{NULL}, \command{rules} readds precedence
over \command{wildcard} and \command{values}. In this case, the names of \command{rules}
act as wildcards, and each corresponding element of \command{rules} acts as a 
\command{values} argument in a recursive call to \command{evaluate}.
}

