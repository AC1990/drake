---
title: "Graphs with drake"
subtitle: "Visualize your workflow."
author: "William Michael Landau"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{graph}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

![](logo-vignettes.png)

```{r, echo = FALSE}
knitr::opts_chunk$set(eval = FALSE)
```


`Drake` has powerful visuals to help you understand and plan your workflow. The workflow plan graph is interactive. Click, drag, hover, zoom, and pan. Use either the mouse or the green buttons near the bottom.


# Dependency reactivity

Initially, your entire project is out of date.

```{r graphoutdated}
library(drake)
load_basic_example()
plot_graph(my_plan)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/outdated.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>


In the previous graph, all the targets were out of date. But after a `make()`, we will be all caught up, and the graph will show you.

```{r graphmake}
make(my_plan, jobs = 4)
plot_graph(my_plan)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/built.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>


But when you change a dependency, you throw some targets out of date until you call `make(my_plan)` again.

```{r reg2graphvisual}
reg2 <- function(d){
  d$x3 <- d$x ^ 3
  lm(y ~ x3, data = d)
}
plot_graph(my_plan)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/reg2.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>

# Subgraphs

Graphs can grow enormous for serious projects, so there are multiple ways to focus on a manageable subgraph. Use `targets_only` to ignore the imports.

```{r targetsonly}
plot_graph(my_plan, targets_only = TRUE)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/targetsonly.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>


Similarly, you can just show downstream nodes.

```{r fromout}
plot_graph(my_plan, from = c("regression2_small", "regression2_large"))
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/fromout.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>


Or upstream ones.

```{r fromin}
plot_graph(my_plan, from = "small", mode = "in")
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/fromin.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>

In fact, let's just take a small neighborhood around a target.


```{r fromall}
plot_graph(my_plan, from = "small", mode = "all", order = 1)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/fromall.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>

The `report.md` node is far to the right because it is in a later parallelizable stage. If you do not care about parallelizable stages, simply `shrink_edges`.

```{r shrink}
plot_graph(
  my_plan,
  from = "small",
  mode = "all",
  order = 1,
  shrink_edges = TRUE
)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/b0169ed6/images/shrink.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>

# Finer control

We have only scratched the surface of `plot_graph()`, there is much more functionality documented in the help file (`?plot_graph`). In addition, `dataframes_graph()` outputs a list of nodes, edges, and legend nodes that you can modify and then feed right into your own [visNetwork graph](http://datastorm-open.github.io/visNetwork/).


# Parallel computing laid bare

When you call `make(my_plan, jobs = 8)`, the work proceeds in chronological order from left to right in the above graph. The items are built or imported column by column in sequence, and up-to-date targets are skipped. Within each column, the targets/objects are all independent of each other conditional on the previous steps, so they are distributed over the 4 available parallel jobs/workers. Assuming the targets are rate-limiting (as opposed to imported objects), the next `make(..., jobs = 8)` should be faster than `make(..., jobs = 1)`, but it would be superfluous to use more than 8 jobs.
