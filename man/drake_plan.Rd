% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/workplan.R
\name{drake_plan}
\alias{drake_plan}
\title{Create a workflow plan data frame
for the \code{plan} argument of \code{\link[=make]{make()}}.}
\usage{
drake_plan(..., list = character(0), file_targets = NULL,
  strings_in_dots = NULL, tidy_evaluation = TRUE)
}
\arguments{
\item{...}{A collection of symbols/targets
with commands assigned to them. See the examples for details.}

\item{list}{A named character vector of commands
with names as targets.}

\item{file_targets}{deprecated argument. See \code{\link[=file_output]{file_output()}},
\code{\link[=file_input]{file_input()}}, and \code{\link[=knitr_input]{knitr_input()}} for the new way to work
with files.
In the past, this argument was a logical to indicate whether the
target names should be single-quoted to denote files. But the newer
interface is much better.}

\item{strings_in_dots}{deprecated argument. See \code{\link[=file_output]{file_output()}},
\code{\link[=file_input]{file_input()}}, and \code{\link[=knitr_input]{knitr_input()}} for the new way to work
with files.
In the past, this argument was a logical to indicate whether the
target names should be single-quoted to denote files. But the newer
interface is much better.

In the past, this argument was a character scalar denoting
how to treat quoted character strings in the commands
specified through \code{...}.
Set to \code{"filenames"} to treat all these strings as
external file targets/imports (single-quoted),
or to \code{"literals"} to treat them all as literal
strings (double-quoted).
Unfortunately, because of how R deparses code,
you cannot simply leave literal quotes alone in the
\code{...} argument. R will either convert all these quotes
to single quotes or double quotes. Literal quotes in the
\code{list} argument are left alone.}

\item{tidy_evaluation}{logical, whether to use tidy evaluation
such as quasiquotation
when evaluating commands passed through the free-form
\code{...} argument.}
}
\value{
A data frame of targets and commands.
}
\description{
Turns a named collection of target/command pairs into
a workflow plan data frame for \code{\link[=make]{make()}} and
\code{\link[=check]{check()}}. You can give the commands
as named expressions, or you can use the \code{list}
argument to supply them as character strings.
}
\details{
A workflow plan data frame is a data frame
with a \code{target} column and a \code{command} column.
Targets are the objects and files that drake generates,
and commands are the pieces of R code that produce them.

To use custom files in your workflow plan,
use the \code{\link[=file_input]{file_input()}}, \code{\link[=knitr_input]{knitr_input()}}, and
\code{\link[=file_output]{file_output()}} functions in your commands.
the examples in this help file provide some guidance.
}
\examples{
test_with_dir("Contain side effects", {
# Create workflow plan data frames.
mtcars_plan <- drake_plan(
  write.csv(mtcars[, c("mpg", "cyl")], file_output(mtcars.csv)),
  value = read.csv(file_input(mtcars.csv))
)
mtcars_plan
make(mtcars_plan) # Makes `mtcars.csv` and then `value`
head(readd(value))
# You can use knitr inputs too. See the top command below.
load_basic_example()
head(my_plan)
# The `knitr_input(report.Rmd)` tells `drake` to dive into the active
# code chunks to find dependencies. In other words, your
# `report.md` file will depend on these targets
# loaded into the report itself:
deps("report.Rmd")
# Are you a fan of tidy evaluation?
my_variable <- 1
drake_plan(
  a = !!my_variable,
  b = !!my_variable + 1,
  list = c(d = "!!my_variable")
)
drake_plan(
  a = !!my_variable,
  b = !!my_variable + 1,
  list = c(d = "!!my_variable"),
  tidy_evaluation = FALSE
)
# For instances of !! that remain unevaluated in the workflow plan,
# make() will run these commands in tidy fashion,
# evaluating the !! operator using the environment you provided.
})
}
