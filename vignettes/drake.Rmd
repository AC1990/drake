---
title: "drake"
subtitle: "data frames in R for Make"
author: "William Michael Landau"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{drake}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = F}
suppressMessages(suppressWarnings(library(drake)))
suppressMessages(suppressWarnings(library(magrittr)))
unlink(".drake", recursive = TRUE)
clean(destroy = TRUE, verbose = FALSE)
unlink(c("Makefile", "report.Rmd", "shell.sh", "STDIN.o*", "Thumbs.db"))
knitr::opts_chunk$set(
  collapse = TRUE,
  error = TRUE,
  warning = TRUE
)
```

![](logo-vignettes.png)

# What gets done stays done.

Too many data analysis projects follow a [Sisyphean loop](https://en.wikipedia.org/wiki/Sisyphus):

1. Launch the code.
2. Wait for it to finish.
3. Discover an issue.
4. Restart from scratch.

But `drake` tracks changes. When you update your code or data, `drake` figures out exactly what needs building, and it builds it in the correct order. The next runthrough is shorter, and your progress is steadier and smoother.

```{r drakemake}
load_basic_example()

# First round.
make(my_plan)

# Change some code.
reg2 <- function(d){
  d$x4 <- d$x ^ 4
  lm(y ~ x4, data = d)
}

# Less work for the second round.
make(my_plan)

# No work if nothing changed.
make(my_plan)
```

# Stay reproducible.

The R community likes to emphasize reproducibility. Most people think that means [scientific replicability](https://en.wikipedia.org/wiki/Replication_crisis), literate programming with [knitr](https://yihui.name/knitr/), or version control with [git](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control). But internal consistency is important too. Reproducibility carries the promise that your output matches the code and data it came from. Ordinarily, you might have to rerun everything from scratch just to be sure. But with `drake`, you can just check that all your targets are up to date.

```{r drakemake2}
make(my_plan)

config <- drake_config(my_plan, verbose = FALSE)
outdated(config)
```

# Aggressively scale up.

Not every project can complete in a single R session on your laptop. Some projects need more speed or computing power. Some require a few local processor cores, and some need large high-performance computing systems. But parallel computing is hard. Your tables and figures depend on your analysis results, and your analyses depend on your datasets, so some tasks must finish before others even begin. But `drake` knows what to do. Parallelism is implicit and automatic. See the [parallelism vignette](https://github.com/wlandau-lilly/drake/blob/master/vignettes/parallelism.Rmd) for all the details.

```{r implicitparallel, eval = FALSE}
# Use the spare cores on your local machine.
make(my_plan, jobs = 4)

# Scale up to a supercomputer.
drake_batchtools_tmpl_file("slurm") # https://slurm.schedmd.com/
library(future.batchtools)
batchtools_slurm(template = "batchtools.slurm.tmpl", workers = 100)
make(my_plan, parallelism = "future_lapply")
```

The network graph allows `drake` to wait for dependencies regardless of scale.

```{r visgraphdrake, eval = FALSE}
# Change some code.
reg2 <- function(d){
  d$x3 <- d$x ^ 3
  lm(y ~ x3, data = d)
}

# Plot an interactive graph. Hover, click, drag, etc.
config <- drake_config(my_plan)
vis_drake_graph(config)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/bd8a086f/images/reg2.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>

Within each column above, the nodes are conditionally independent given their dependencies. Each `make()` walks through the columns from left to right and applies parallel processing within each column. If any nodes are already up to date, `drake` looks downstream to maximize the number of outdated targets in a parallelizable stage. To show the parallelizable stages of the next `make()` programmatically, use the `parallel_stages()` function.

Parallel backends range from local multicore computing to serious [future.batchtools](https://github.com/HenrikBengtsson/future.batchtools/blob/master/README.md)-powered distributed computing on a cluster. See the [parallelism vignette](https://github.com/wlandau-lilly/drake/blob/master/vignettes/parallelism.Rmd) for details.

# Where to begin

Outline your project in a data frame of targets.

```{r myplandrakevig}
# Remove work from the previous example.
clean()

load_basic_example(verbose = FALSE)
my_plan
```

Wildcard templating generates these data frames at scale.

```{r plan_drakegeneration}
library(magrittr)
dataset_plan <- plan_drake(
  small = simulate(5),
  large = simulate(50)
)
dataset_plan

analysis_methods <- plan_drake(
  regression = regNUMBER(dataset__) # nolint
) %>%
  evaluate_plan(wildcard = "NUMBER", values = 1:2)
analysis_methods

analysis_plan <- plan_analyses(
  plan = analysis_methods,
  datasets = dataset_plan
)
analysis_plan

whole_plan <- rbind(dataset_plan, analysis_plan)
whole_plan
```

Using static code analysis, `drake` detects the dependencies of all your targets. The result is an interactive network diagram.

```{r drakevisgraph, eval = FALSE}
vis_drake_graph(my_plan)
```

<iframe
src = "https://cdn.rawgit.com/wlandau-lilly/drake/bd8a086f/images/outdated.html"
width = "100%" height = "600px" allowtransparency="true"
style="border: none; box-shadow: none">
</iframe>

At this point, all your targets are out of date because the project is new.

```{r outdateddrake}
config <- drake_config(my_plan, verbose = FALSE) # Master configuration list
outdated(config)
```

The `make()` function traverses the network and builds the targets that require updates.

```{r firstmakedrake}
make(my_plan)
```

The project is now up to date, so the next `make()` does nothing.

```{r makeuptodatedrake}
make(my_plan)
```

But a nontrivial change in `reg2()` triggers updates to all the affected downstream targets.

```{r reg2makedrake}
reg2 <- function(d){
  d$x3 <- d$x ^ 3
  lm(y ~ x3, data = d)
}

make(my_plan)
```

# Acknowledgements

Many thanks to [Julia Lowndes](https://github.com/jules32) and [Ben Marwick](https://github.com/benmarwick) for [reviewing drake for rOpenSci](https://github.com/ropensci/onboarding/issues/156). Thanks also to the following people for contributing early in development.

- [Alex Axthelm](https://github.com/AlexAxthelm)
- [Chan-Yub Park](https://github.com/mrchypark)
- [Daniel Falster](https://github.com/dfalster)
- [Eric Nantz](https://github.com/enantz-lilly)
- [Henrik Bengtsson](https://github.com/HenrikBengtsson)
- [Jasper Clarkberg](https://github.com/dapperjapper)
- [Kendon Bell](https://github.com/kendonB)
- [Kirill M&uuml;ller](https://github.com/krlmlr)

Special thanks to [Jarad Niemi](http://www.jarad.me/), my advisor from [graduate school](http://stat.iastate.edu/), for first introducing me to the idea of [Makefiles](https://www.gnu.org/software/make/) for research. It took several months to convince me, and I am grateful that he succeeded.

```{r rmfiles_main, echo = FALSE}
clean(destroy = TRUE, verbose = FALSE)
unlink(c("Makefile", "report.Rmd", "shell.sh", "STDIN.o*", "Thumbs.db"))
```
